<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: bin/swagger-spec-validator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: bin/swagger-spec-validator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>#!/usr/bin/env node
/**
 * swagger-spec-validator executable command.
 *
 * @copyright Copyright 2017 Kevin Locke &lt;kevin@kevinlocke.name>
 * @license MIT
 */

'use strict';

const Yargs = require('yargs/yargs');
const arrayUniq = require('array-uniq');
const assign = require('object-assign');
const packageJson = require('../package.json');
const swaggerSpecValidator = require('..');
const url = require('url');

function parseHeader(line) {
  // Note: curl uses the header line literally.  We can't due to Node API.
  //       Node enforces name is a valid RFC 7230 token, so remove whitespace
  //       as a convenience for users.
  const match = /^\s*(\S+)\s*: ?(.*)$/.exec(line);
  if (!match) {
    throw new Error(`Unable to parse header line "${line}"`);
  }

  const name = match[1];
  const value = match[2];
  return [name, value];
}

function parseHeaders(lines) {
  return lines
    // yargs passes [undefined] when insufficient arguments are given
    .filter((line) => line !== null &amp;&amp; line !== undefined)
    .map(parseHeader)
    .reduce((headerObj, header) => {
      headerObj[header[0]] = header[1];
      return headerObj;
    }, {});
}

/** Calls &lt;code>yargs.parse&lt;/code> and passes any thrown errors to the callback.
 * Workaround for https://github.com/yargs/yargs/issues/755
 * @private
 */
function parseYargs(yargs, args, callback) {
  // Since yargs doesn't nextTick its callback, this function must be careful
  // that exceptions thrown from callback (which propagate through yargs.parse)
  // are not caught and passed to a second invocation of callback.
  let called = false;
  try {
    yargs.parse(args, function() {
      called = true;
      return callback.apply(this, arguments);
    });
  } catch (err) {
    if (called) {
      // err was thrown after or by callback.  Let it propagate.
      throw err;
    } else {
      callback(err);
    }
  }
}

/** Gets validation messages from a validation response object.
 * @private
 */
function getMessages(result) {
  let messages = [];
  if (result.messages) {
    messages = messages.concat(result.messages);
  }
  if (result.schemaValidationMessages) {
    messages = messages.concat(
      result.schemaValidationMessages.map((m) => `${m.level}: ${m.message}`)
    );
  }
  return messages;
}

function validateAll(specPaths, options, callback) {
  let hadError = false;
  let hadInvalid = false;
  let numValidated = 0;
  specPaths.forEach((specPath) => {
    function onResult(err, result) {
      if (err) {
        hadError = true;
        if (options.verbosity >= -1) {
          options.err.write(`${specPath}: ${err}\n`);
          if (options.verbosity >= 1) {
            options.err.write(err.stack);
          }
        }
      } else {
        const messages = getMessages(result);
        if (messages.length > 0) {
          hadInvalid = true;
          if (options.verbosity >= 0) {
            const messagesWithPath =
              messages.map((message) => `${specPath}: ${message}`);
            options.out.write(`${messagesWithPath.join('\n')}\n`);
          }
        }
      }

      numValidated += 1;
      if (numValidated === specPaths.length) {
        if (!hadError &amp;&amp; !hadInvalid &amp;&amp; options.verbosity >= 0) {
          options.err.write('All OpenAPI/Swagger specs are valid.\n');
        }

        callback(null, hadError ? 2 : hadInvalid ? 1 : 0);
      }
    }

    if (specPath === '-') {
      swaggerSpecValidator.validate(options.in, options, onResult);
    } else {
      swaggerSpecValidator.validateFile(specPath, options, onResult);
    }
  });
}

/** Options for command entry points.
 *
 * @typedef {{
 *   in: (stream.Readable|undefined),
 *   out: (stream.Writable|undefined),
 *   err: (stream.Writable|undefined)
 * }} CommandOptions
 * @property {stream.Readable=} in Stream from which input is read. (default:
 * &lt;code>process.stdin&lt;/code>)
 * @property {stream.Writable=} out Stream to which output is written.
 * (default: &lt;code>process.stdout&lt;/code>)
 * @property {stream.Writable=} err Stream to which errors (and non-output
 * status messages) are written. (default: &lt;code>process.stderr&lt;/code>)
 */
// const CommandOptions;

/** Entry point for this command.
 *
 * @param {!Array&lt;string>} args Command-line arguments.
 * @param {CommandOptions=} options Options.
 * @param {?function(Error, number=)=}
 * callback Callback for the exit code or an &lt;code>Error&lt;/code>.
 * @return {Promise&lt;number>|undefined} If &lt;code>callback&lt;/code> is not given, a
 * &lt;code>Promise&lt;/code> with the exit code or &lt;code>Error&lt;/code>.
 * @exports swagger-spec-validator/bin/swagger-spec-validator
 */
function swaggerSpecValidatorCmd(args, options, callback) {
  if (!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    return new Promise((resolve, reject) => {
      swaggerSpecValidatorCmd(args, options, (err, result) => {
        if (err) { reject(err); } else { resolve(result); }
      });
    });
  }

  if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  }

  try {
    if (args === undefined || args === null) {
      args = [];
    } else if (typeof args !== 'object' ||
               Math.floor(args.length) !== args.length) {
      throw new TypeError('args must be Array-like');
    } else if (args.length &lt; 2 &amp;&amp; args.length !== 0) {
      throw new RangeError('args must have at least 2 elements');
    } else {
      args = Array.prototype.slice.call(args, 2).map(String);
    }

    if (options !== undefined &amp;&amp; typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }

    options = Object.assign(
      {
        in: process.stdin,
        out: process.stdout,
        err: process.stderr
      },
      options
    );

    if (!options.in || typeof options.in.on !== 'function') {
      throw new TypeError('options.in must be a stream.Readable');
    }
    if (!options.out || typeof options.out.write !== 'function') {
      throw new TypeError('options.out must be a stream.Writable');
    }
    if (!options.err || typeof options.err.write !== 'function') {
      throw new TypeError('options.err must be a stream.Writable');
    }
  } catch (err) {
    process.nextTick(() => {
      callback(err);
    });
    return undefined;
  }

  // Workaround for https://github.com/yargs/yargs/issues/783
  require.main = module;
  const yargs = new Yargs(null, null, require)
    .usage('Usage: $0 [options] [swagger.yaml...]')
    .option('header', {
      alias: 'H',
      describe: 'Additional HTTP header to send',
      requiresArg: true,
      array: true,
      // Prevent array from eating non-option arguments
      nargs: 1,
      coerce: parseHeaders
    })
    .help()
    .alias('help', 'h')
    .alias('help', '?')
    .option('quiet', {
      alias: 'q',
      describe: 'Print less output',
      count: true
    })
    .option('url', {
      alias: 'u',
      describe: 'Validator URL',
      defaultDescription: swaggerSpecValidator.DEFAULT_URL,
      nargs: 1
    })
    .option('verbose', {
      alias: 'v',
      describe: 'Print more output',
      count: true
    })
    .version(`${packageJson.name} ${packageJson.version}`)
    .alias('version', 'V')
    .strict();
  parseYargs(yargs, args, (err, argOpts, output) => {
    if (err) {
      if (output) {
        options.err.write(`${output}\n`);
      } else {
        options.err.write(`${err.name}: ${err.message}\n`);
      }
      callback(null, 3);
      return;
    }

    if (output) {
      options.out.write(`${output}\n`);
    }

    if (argOpts.help || argOpts.version) {
      callback(null, 0);
      return;
    }

    const verbosity = argOpts.verbose - argOpts.quiet;

    let specPaths = argOpts._;
    if (specPaths.length === 0) {
      // Default to validating stdin
      specPaths.push('-');
      if (verbosity > 1) {
        options.out.write('Reading spec from stdin...\n');
      }
    } else if (specPaths.length > 1) {
      specPaths = arrayUniq(specPaths);
    }

    const validateOpts = assign({}, options);
    validateOpts.request = argOpts.url ? url.parse(argOpts.url) : {};
    validateOpts.request.headers = argOpts.header;
    validateOpts.verbosity = verbosity;

    validateAll(specPaths, validateOpts, callback);
  });

  return undefined;
}

swaggerSpecValidatorCmd.default = swaggerSpecValidatorCmd;
module.exports = swaggerSpecValidatorCmd;

if (require.main === module) {
  // This file was invoked directly.
  /* eslint-disable no-process-exit */
  const mainOptions = {
    in: process.stdin,
    out: process.stdout,
    err: process.stderr
  };
  swaggerSpecValidatorCmd(process.argv, mainOptions, (err, exitCode) => {
    if (err) {
      if (err.stdout) { process.stdout.write(err.stdout); }
      if (err.stderr) { process.stderr.write(err.stderr); }
      process.stderr.write(`${err.name}: ${err.message}\n`);

      exitCode = typeof err.exitCode === 'number' ? err.exitCode : 1;
    }

    process.exit(exitCode);
  });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-swagger-spec-validator.html">swagger-spec-validator</a></li><li><a href="module-swagger-spec-validator_bin_swagger-spec-validator.html">swagger-spec-validator/bin/swagger-spec-validator</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Apr 19 2018 09:59:48 GMT-0600 (MDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
